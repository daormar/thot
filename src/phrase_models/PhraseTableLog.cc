/*
thot package for statistical machine translation
Copyright (C) 2013 Daniel Ortiz-Mart\'inez
 
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public License
as published by the Free Software Foundation; either version 3
of the License, or (at your option) any later version.
 
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.
 
You should have received a copy of the GNU Lesser General Public License
along with this program; If not, see <http://www.gnu.org/licenses/>.
*/
 
/********************************************************************/
/*                                                                  */
/* Module: PhraseTableLog                                           */
/*                                                                  */
/* Definitions file: PhraseTableLog.cc                              */
/*                                                                  */
/********************************************************************/


//--------------- Include files --------------------------------------

#include "PhraseTableLog.h"

//--------------- Function definitions

//-------------------------
PhraseTableLog::PhraseTableLog(void)
{
}

//-------------------------
bool PhraseTableLog::getNbestForSrc(const Vector<WordIndex>& s,
                                    NbestTableNode<PhraseTransTableNodeData>& nbt)
{
  PhraseCountLogState pls_state;
  
  pls_state=s_LogCounts.getState(s);
  if(pls_state==NULL) return false;
  else
  {
    nbt=phraseDictLog.getTranslationsFor_s_(pls_state);
    return true;
  }
}

//-------------------------
bool PhraseTableLog::getNbestForTrg(const Vector<WordIndex>& t,
                                    NbestTableNode<PhraseTransTableNodeData>& nbt,
                                    int N)
{
  PhraseTableNodeLog* ptnodel;
  PhraseTableNodeLog::iterator ptnlIter;	
  LogCount lcount_t_;	
  LgProb lgProb;
  Vector<WordIndex> s;

  nbt.clear();
  
  lcount_t_=phraseDictLog.getLogCount_t(t);
  if((float)lcount_t_>SMALL_LG_NUM)
  {
    //Find the phrase-model entry for phrase f
    ptnodel=phraseDictLog.getTranslationsFor_t_(t);
    // generate transTableNode
    for(ptnlIter=ptnodel->begin();ptnlIter!=ptnodel->end();++ptnlIter) 
    {
          // Check if the count for the source phrase is zero. If the
          // count is zero the entry is discarded. This is useful to
          // discard the special translation options generated by the
          // "get_nbest_for_trg" tool that are inserted in the phrase
          // table. Such special translation options store the remainder
          // of the joint counts that are pruned by the
          // "get_nbest_for_trg" tool. The remainder allows to keep the
          // same value of the count for the target phrases.
      if((float)s_LogCounts.getLogCountGivenState(ptnlIter->first)>SMALL_LG_NUM)
      {
        lgProb=(float)ptnlIter->second-(float)lcount_t_;
            // Insert entry into translation table node
        s_LogCounts.getPhraseGivenState(ptnlIter->first,s);
        nbt.insert(lgProb,s);
      }
    }
    
#   ifdef DO_STABLE_SORT_ON_NBEST_TABLE
        // Performs stable sort on n-best table, this is done to ensure
        // that the n-best lists generated by cache models and
        // conventional models are identical. However this process is
        // time consuming and must be avoided if possible
    nbt.stableSort();
#   endif
    
    while(nbt.size()>(unsigned int)N && N>=0)
    {// node contains N inverse translations, remove last element
      nbt.removeLastElement();
    }
    return true;
  }
  else
  {// phrase f is not stored	  
    return false;
  }
}

//-------------------------
void PhraseTableLog::addTableEntry(const Vector<WordIndex>& s,
                                   const Vector<WordIndex>& t,
                                   PhrasePairInfo inf) 
{
  PhraseCountLogState pls_state;

      // Revise source phrase count
  pls_state=s_LogCounts.addPhrase(s,(double)log((double)inf.first));
      // Revise phraseDictLog
  phraseDictLog.addSrcTrgPair(pls_state,t,(double)log((double)inf.second));  
}

//-------------------------
void PhraseTableLog::addTableEntry(const Vector<WordIndex>& s,
                                   const Vector<WordIndex>& t,
                                   LogCount lcs,
                                   LogCount lcst)
{
  PhraseCountLogState pls_state;

      // Revise source phrase count
  pls_state=s_LogCounts.addPhrase(s,lcs);
      // Revise phraseDictLog
  phraseDictLog.addSrcTrgPair(pls_state,t,lcst);  
}

//-------------------------
void PhraseTableLog::addSrcInfo(const Vector<WordIndex>& s,
                                Count s_inf)
{
  // Revise source phrase count
  s_LogCounts.addPhrase(s,(double)log((double)s_inf));
}

//-------------------------
void PhraseTableLog::addSrcTrgInfo(const Vector<WordIndex>& s,
                                   const Vector<WordIndex>& t,
                                   Count st_inf)
{
  PhraseCountLogState pls_state;

  pls_state=s_LogCounts.getState(s);
  if(pls_state!=NULL)
  {
    phraseDictLog.addSrcTrgPair(pls_state,t,(double)log((double)st_inf));  
  }
  else
  {
    pls_state=s_LogCounts.addPhrase(s,SMALL_LG_NUM);
    phraseDictLog.addSrcTrgPair(pls_state,t,(double)log((double)st_inf));    
  }
}

//-------------------------
void PhraseTableLog::incrCountsOfEntry(const Vector<WordIndex>& s,
                                       const Vector<WordIndex>& t,
                                       Count c) 
{
  PhraseCountLogState pls_state;

  // Revise source phrase count
  pls_state=s_LogCounts.incrLogCountOfPhrase(s,(double)log((double)c));
  
  // Revise phraseDictLog count
  phraseDictLog.incrSrcTrgLogCount(pls_state,t,(double)log((double)c));
}

//-------------------------
void PhraseTableLog::incrCountsOfEntryLog(const Vector<WordIndex>& s,
                                          const Vector<WordIndex>& t,
                                          LogCount lc) 
{
  PhraseCountLogState pls_state;

  // Revise source phrase count
  pls_state=s_LogCounts.incrLogCountOfPhrase(s,lc);
  
  // Revise phraseDictLog count
  phraseDictLog.incrSrcTrgLogCount(pls_state,t,lc);
}

//-------------------------
PhrasePairInfo PhraseTableLog::infSrcTrg(const Vector<WordIndex>& s,
                                         const Vector<WordIndex>& t,
                                         bool& found) 
{
  PhrasePairInfo ppi;

  ppi.first=getSrcInfo(s,found);
  if(!found)
  {
    ppi.second=0;
    return ppi;
  }
  else
  {
    ppi.second=getSrcTrgInfo(s,t,found);
    return ppi;
  }
}

//-------------------------
Count PhraseTableLog::getSrcInfo(const Vector<WordIndex>& s,
                                 bool &found)
{
  Count c;
  c=exp((float) getSrcLogCount(s,found));

  return c;
}

//-------------------------
LogCount PhraseTableLog::getSrcLogCount(const Vector<WordIndex>& s,
                                        bool &found)
{
  return s_LogCounts.getLogCount(s,found);
}

//-------------------------
LogCount PhraseTableLog::getSrcTrgLogCount(const Vector<WordIndex>& s,
                                           const Vector<WordIndex>& t,
                                           bool &found)
{
  PhraseCountLogState pls_state;

  pls_state=s_LogCounts.getState(s);
  if(pls_state==NULL)
  {
    found=false;
    return SMALL_LG_NUM;
  }
  else
  {
    return phraseDictLog.getLogCounts_t_(pls_state,t,found);
  }    
}

//-------------------------
Count PhraseTableLog::getSrcTrgInfo(const Vector<WordIndex>& s,
                                    const Vector<WordIndex>& t,
                                    bool &found)
{
  PhraseCountLogState pls_state;

  pls_state=s_LogCounts.getState(s);
  if(pls_state==NULL)
  {
    found=false;
    return 0;
  }
  else
  {
    Count c;
    c=exp((float)phraseDictLog.getLogCounts_t_(pls_state,t,found));
    return c;
  }    
}

//-------------------------
Prob PhraseTableLog::pTrgGivenSrc(const Vector<WordIndex>& s,
                                  const Vector<WordIndex>& t)
{
  return exp((float)logpTrgGivenSrc(s,t));
}

//-------------------------
LgProb PhraseTableLog::logpTrgGivenSrc(const Vector<WordIndex>& s,
                                       const Vector<WordIndex>& t)
{
  LogCount lcount_s_t_,lcount_s;
  bool found;
  
  lcount_s_t_=getSrcTrgLogCount(s,t,found);	
  if((float)lcount_s_t_>SMALL_LG_NUM)
  {
    lcount_s=s_LogCounts.getLogCount(s,found);
	if((float)lcount_s>SMALL_LG_NUM)
    {
      return (float)lcount_s_t_-(float)lcount_s;
    }
	else return SMALL_LG_NUM;
  }
  else return SMALL_LG_NUM;
}

//-------------------------
Prob PhraseTableLog::pSrcGivenTrg(const Vector<WordIndex>& s,
                                  const Vector<WordIndex>& t)
{
  return exp((float)logpSrcGivenTrg(s,t));
}

//-------------------------
LgProb PhraseTableLog::logpSrcGivenTrg(const Vector<WordIndex>& s,
                                       const Vector<WordIndex>& t)
{
  LogCount lcount_s_t_,lcount_t_;

  lcount_t_=phraseDictLog.getLogCount_t(t);
  if((float)lcount_t_<=SMALL_LG_NUM) return SMALL_LG_NUM;
  else
  {
    bool found;
    lcount_s_t_=getSrcTrgLogCount(s,t,found);
    return (float)lcount_s_t_-(float)lcount_t_;
  }
}

//-------------------------
bool PhraseTableLog::getEntriesForTarget(const Vector<WordIndex>& t,
                                         PhraseTableLog::SrcTableNode& srctn) 
{
  pair<bool,PhraseTableNodeLog*> p_bool_ptnodel;

  p_bool_ptnodel=nodeForTrgHasOneTransOrMore(t);
  if(p_bool_ptnodel.first)
  { //There are entries for the target phrase t in the dictionary

        // generate SrcTableNode
    return getEntriesForTarget(p_bool_ptnodel.second,srctn);
  }
  else return false;
}

//-------------------------
bool PhraseTableLog::getEntriesForTarget(PhraseTableNodeLog* ptnPtr,
                                         PhraseTableLog::SrcTableNode& srctn)
{
  PhraseTableNodeLog::iterator ptnlIter;
  Vector<WordIndex> s;
  PhrasePairInfo phpinfo;

  srctn.clear();
    
  if(ptnPtr->size()==0) return false;
  
          // generate SrcTableNode
  for(ptnlIter=ptnPtr->begin();ptnlIter!=ptnPtr->end();++ptnlIter) 
  {
        // Check if the count for the source phrase is zero. If the
        // count is zero the entry is discarded. This is useful to
        // discard the special translation options generated by the
        // "get_nbest_for_trg" tool that are inserted in the phrase
        // table. Such special translation options store the remainder
        // of the joint counts that are pruned by the
        // "get_nbest_for_trg" tool. The remainder allows to keep the
        // same value of the count for the target phrases.
    if((float)s_LogCounts.getLogCountGivenState(ptnlIter->first)>(float)SMALL_LG_NUM)
    {
      phpinfo.first=exp((float)s_LogCounts.getLogCountGivenState(ptnlIter->first));
      phpinfo.second=exp((float)ptnlIter->second);
      s_LogCounts.getPhraseGivenState(ptnlIter->first,s);
    
      	  // Insert entry into translation table node
      srctn[s]=phpinfo;
    }
  }
  return true;
}

//-------------------------
bool PhraseTableLog::getEntriesForSource(const Vector<WordIndex>& s,
                                         PhraseTableLog::TrgTableNode& trgtn) 
{
  PhraseCountLogState pls_state;
    
  pls_state=s_LogCounts.getState(s);
  trgtn=phraseDictLog.getEntriesFor_s(pls_state);
  if(trgtn.size()==0) return false;
  else return true;
}

//-------------------------
Count PhraseTableLog::cSrcTrg(const Vector<WordIndex>& s,
                              const Vector<WordIndex>& t)
{
  bool found;
  return getSrcTrgInfo(s,t,found).get_c_st();
}

//-------------------------
Count PhraseTableLog::cSrc(const Vector<WordIndex>& s)
{
  bool found;
  return getSrcInfo(s,found).get_c_s();
}

//-------------------------
Count PhraseTableLog::cTrg(const Vector<WordIndex>& t)
{
  return exp((float)phraseDictLog.getLogCount_t(t));  
}

//-------------------------
LogCount PhraseTableLog::lcSrcTrg(const Vector<WordIndex>& s,
                                  const Vector<WordIndex>& t)
{
  bool found;
  return getSrcTrgLogCount(s,t,found);
}

//-------------------------
LogCount PhraseTableLog::lcSrc(const Vector<WordIndex>& s)
{
  bool found;
  return getSrcLogCount(s,found);
}

//-------------------------
LogCount PhraseTableLog::lcTrg(const Vector<WordIndex>& t)
{
  return (float)phraseDictLog.getLogCount_t(t);  
}

//-------------------------
bool PhraseTableLog::nodeForTrgHasAtLeastOneTrans(const Vector<WordIndex>& t)
{
  pair<bool,PhraseTableNodeLog*> pbp;

  pbp=nodeForTrgHasOneTransOrMore(t);
  return pbp.first;
}

//-------------------------
pair<bool,PhraseTableNodeLog*> PhraseTableLog::nodeForTrgHasOneTransOrMore(const Vector<WordIndex>& t)
{
  return phraseDictLog.nodeForTrgHasOneTransOrMore(t);
}

//-------------------------
void PhraseTableLog::getPhraseGivenState(PhraseCountLogState pls_state,
                                         Vector<WordIndex>& s_phrase)
{
  s_LogCounts.getPhraseGivenState(pls_state,s_phrase);
}

//-------------------------
Count PhraseTableLog::getCountGivenState(PhraseCountLogState pls_state)
{
  return (double)exp((double)s_LogCounts.getLogCountGivenState(pls_state));
}

//-------------------------
size_t PhraseTableLog::size(void)
{
  return phraseDictLog.size();
}
//-------------------------
void PhraseTableLog::clear(void)
{
  phraseDictLog.clear();
  s_LogCounts.clear();
}

//-------------------------
PhraseTableLog::~PhraseTableLog(void)
{

}

//-------------------------
PhraseTableLog::const_iterator PhraseTableLog::begin(void)const
{
  PhraseTableLog::const_iterator iter(this,phraseDictLog.begin());
  return iter;
}
//-------------------------
PhraseTableLog::const_iterator PhraseTableLog::end(void)const
{
  PhraseTableLog::const_iterator iter(this,phraseDictLog.end());
  return iter;
}

// const_iterator function definitions
//--------------------------
bool PhraseTableLog::const_iterator::operator++(void) //prefix
{
  if(ptPtr!=NULL)
  {
    ++pdIter;
    if(pdIter==ptPtr->phraseDictLog.end()) return false;
    else
    {
      return true;
    }
  }
  else return false;
}
//--------------------------
bool PhraseTableLog::const_iterator::operator++(int)  //postfix
{
  return operator++();
}
//--------------------------
int PhraseTableLog::const_iterator::operator==(const const_iterator& right)
{
  return (ptPtr==right.ptPtr && pdIter==right.pdIter);	
}
//--------------------------
int PhraseTableLog::const_iterator::operator!=(const const_iterator& right)
{
  return !((*this)==right);
}
//--------------------------
PhraseDictLog::const_iterator& PhraseTableLog::const_iterator::operator->(void)
{
  return pdIter;
}

//-------------------------
