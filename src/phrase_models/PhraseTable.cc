/*
thot package for statistical machine translation
Copyright (C) 2013 Daniel Ortiz-Mart\'inez
 
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public License
as published by the Free Software Foundation; either version 3
of the License, or (at your option) any later version.
 
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.
 
You should have received a copy of the GNU Lesser General Public License
along with this program; If not, see <http://www.gnu.org/licenses/>.
*/
 
/********************************************************************/
/*                                                                  */
/* Module: PhraseTable                                              */
/*                                                                  */
/* Definitions file: PhraseTable.cc                                 */
/*                                                                  */
/********************************************************************/


//--------------- Include files --------------------------------------

#include "PhraseTable.h"

//--------------- Function definitions

//-------------------------
PhraseTable::PhraseTable(void)
{
}
//-------------------------
bool PhraseTable::getNbestForSrc(const Vector<WordIndex>& s,
                                 NbestTableNode<PhraseTransTableNodeData>& nbt)
{
  PhraseCountState ps_state;
  
  ps_state=sourcePhraseCounts.getState(s);
  if(ps_state==NULL) return false;
  else
  {
    nbt=phraseDict.getTranslationsFor_s_(ps_state);
    return true;
  }
}
//-------------------------
bool PhraseTable::getNbestForTrg(const Vector<WordIndex>& t,
                                 NbestTableNode<PhraseTransTableNodeData>& nbt,
                                 int N)
{
  PhraseTableNode* ptNode;
  PhraseTableNode::iterator phraseTNodeIter;	
  Count count_t_;	
  LgProb lgProb;
  Vector<WordIndex> s;

  nbt.clear();
  
  count_t_=cTrg(t);
  if((float)count_t_>0)
  {
    //Find the phrase-model entry for phrase f
    ptNode=phraseDict.getTranslationsFor_t_(t);
    // generate transTableNode
    for(phraseTNodeIter=ptNode->begin();phraseTNodeIter!=ptNode->end();++phraseTNodeIter) 
    {
          // Check if the count for the source phrase is zero. If the
          // count is zero the entry is discarded. This is useful to
          // discard the special translation options generated by the
          // "get_nbest_for_trg" tool that are inserted in the phrase
          // table. Such special translation options store the remainder
          // of the joint counts that are pruned by the
          // "get_nbest_for_trg" tool. The remainder allows to keep the
          // same value of the count for the target phrases.
      if((float)sourcePhraseCounts.getCountGivenState(phraseTNodeIter->first)>(float)0.0)
      {
        lgProb=log((float)phraseTNodeIter->second.get_c_st()/(float)count_t_);
            // Insert entry into translation table node
        sourcePhraseCounts.getPhraseGivenState(phraseTNodeIter->first,s);
        nbt.insert(lgProb,s);
      }
    }
    
#   ifdef DO_STABLE_SORT_ON_NBEST_TABLE
        // Performs stable sort on n-best table, this is done to ensure
        // that the n-best lists generated by cache models and
        // conventional models are identical. However this process is
        // time consuming and must be avoided if possible
    nbt.stableSort();
#   endif
    
    while(nbt.size()>(unsigned int)N && N>=0)
    {// node contains N inverse translations, remove last element
      nbt.removeLastElement();
    }
    return true;
  }
  else
  {// phrase f is not stored	  
    return false;
  }
}

//-------------------------
void PhraseTable::addTableEntry(const Vector<WordIndex>& s,
                                const Vector<WordIndex>& t,
                                PhrasePairInfo inf) 
{
  PhraseCountState ps_state;

  // Revise source phrase count
  ps_state=sourcePhraseCounts.addPhrase(s,inf.first);
  // Revise phraseDict
  phraseDict.addSrcTrgPair(ps_state,t,inf.second);  
}

//-------------------------
void PhraseTable::addSrcInfo(const Vector<WordIndex>& s,
                             Count s_inf)
{
  // Revise source phrase count
  sourcePhraseCounts.addPhrase(s,s_inf);
}

//-------------------------
void PhraseTable::addSrcTrgInfo(const Vector<WordIndex>& s,
                                const Vector<WordIndex>& t,
                                Count st_inf)
{
  PhraseCountState ps_state;

  ps_state=sourcePhraseCounts.getState(s);
  if(ps_state!=NULL)
  {
    phraseDict.addSrcTrgPair(ps_state,t,st_inf);  
  }
  else
  {
    ps_state=sourcePhraseCounts.addPhrase(s,0);
    phraseDict.addSrcTrgPair(ps_state,t,st_inf);    
  }
}

//-------------------------
void PhraseTable::incrCountsOfEntry(const Vector<WordIndex>& s,
                                    const Vector<WordIndex>& t,
                                    Count c) 
{
  PhraseCountState ps_state;

  // Revise source phrase count
  ps_state=sourcePhraseCounts.incrCountOfPhrase(s,c);
  
  // Revise phraseDict count
  phraseDict.incrSrcTrgCount(ps_state,t,c);
}

//-------------------------
PhrasePairInfo PhraseTable::infSrcTrg(const Vector<WordIndex>& s,
                                      const Vector<WordIndex>& t,
                                      bool& found) 
{
  PhrasePairInfo ppi;

  ppi.first=getSrcInfo(s,found);
  if(!found)
  {
    ppi.second=0;
    return ppi;
  }
  else
  {
    ppi.second=getSrcTrgInfo(s,t,found);
    return ppi;
  }
}

//-------------------------
Count PhraseTable::getSrcInfo(const Vector<WordIndex>& s,
                              bool &found)
{
  Count c;
  c=sourcePhraseCounts.getCount(s,found);

  return c;
}

//-------------------------
Count PhraseTable::getSrcTrgInfo(const Vector<WordIndex>& s,
                                 const Vector<WordIndex>& t,
                                 bool &found)
{
  PhraseCountState ps_state;

  ps_state=sourcePhraseCounts.getState(s);
  if(ps_state==NULL)
  {
    found=false;
    return 0;
  }
  else
  {
    Count c;
    c=phraseDict.getCounts_t_(ps_state,t,found);
    return c;
  }    
}

//-------------------------
Prob PhraseTable::pTrgGivenSrc(const Vector<WordIndex>& s,
                               const Vector<WordIndex>& t)
{
  Count count_s_t_,count_s;
  bool found;
  
  count_s_t_=cSrcTrg(s,t);	
  if((float)count_s_t_>0)
  {
    count_s=sourcePhraseCounts.getCount(s,found);
	if((float)count_s>0)
    {
      return (float) count_s_t_/(float)count_s;
    }
	else return PHRASE_PROB_SMOOTH;
  }
  else return PHRASE_PROB_SMOOTH;
}

//-------------------------
LgProb PhraseTable::logpTrgGivenSrc(const Vector<WordIndex>& s,
                                    const Vector<WordIndex>& t)
{
  return log((double)pTrgGivenSrc(s,t));
}

//-------------------------
Prob PhraseTable::pSrcGivenTrg(const Vector<WordIndex>& s,
                               const Vector<WordIndex>& t)
{
  Count count_s_t_,count_t_;

  count_t_=cTrg(t);
  if((float)count_t_<=0) return PHRASE_PROB_SMOOTH;
  else
  {
    count_s_t_=cSrcTrg(s,t);
    return (float)count_s_t_/(float)count_t_;	  
  }
}

//-------------------------
LgProb PhraseTable::logpSrcGivenTrg(const Vector<WordIndex>& s,
                                    const Vector<WordIndex>& t)
{
  return log((double)pSrcGivenTrg(s,t));
}

//-------------------------
bool PhraseTable::getEntriesForTarget(const Vector<WordIndex>& t,
                                      PhraseTable::SrcTableNode& srctn) 
{
  pair<bool,PhraseTableNode*> p_bool_ptnode;

  p_bool_ptnode=nodeForTrgHasOneTransOrMore(t);
  if(p_bool_ptnode.first)
  {
        // There are entries for the target phrase t in the dictionary
        // generate SrcTableNode
    return getEntriesForTarget(p_bool_ptnode.second,srctn);
  }
  else return false;
}

//-------------------------
bool PhraseTable::getEntriesForTarget(PhraseTableNode* ptnPtr,
                                      PhraseTable::SrcTableNode& srctn)
{
  PhraseTableNode::iterator phraseTNodeIter;
  Vector<WordIndex> s;
  PhrasePairInfo phpinfo;

  srctn.clear();
    
  if(ptnPtr->size()==0) return false;
  
          // generate SrcTableNode
  for(phraseTNodeIter=ptnPtr->begin();phraseTNodeIter!=ptnPtr->end();++phraseTNodeIter) 
  {
        // Check if the count for the source phrase is zero. If the
        // count is zero the entry is discarded. This is useful to
        // discard the special translation options generated by the
        // "get_nbest_for_trg" tool that are inserted in the phrase
        // table. Such special translation options store the remainder
        // of the joint counts that are pruned by the
        // "get_nbest_for_trg" tool. The remainder allows to keep the
        // same value of the count for the target phrases.
    if((float)sourcePhraseCounts.getCountGivenState(phraseTNodeIter->first)>(float)0.0)
    {
      phpinfo.first=sourcePhraseCounts.getCountGivenState(phraseTNodeIter->first);
      phpinfo.second=phraseTNodeIter->second.get_c_st();
      sourcePhraseCounts.getPhraseGivenState(phraseTNodeIter->first,s);
    
      	  // Insert entry into translation table node
      srctn[s]=phpinfo;
    }
  }
  return true;
}

//-------------------------
bool PhraseTable::getEntriesForSource(const Vector<WordIndex>& s,
                                      PhraseTable::TrgTableNode& trgtn) 
{
  PhraseCountState ps_state;
    
  ps_state=sourcePhraseCounts.getState(s);
  trgtn=phraseDict.getEntriesFor_s(ps_state);
  if(trgtn.size()==0) return false;
  else return true;
}

//-------------------------
Count PhraseTable::cSrcTrg(const Vector<WordIndex>& s,
                           const Vector<WordIndex>& t)
{
  bool found;
  return getSrcTrgInfo(s,t,found).get_c_st();
}

//-------------------------
Count PhraseTable::cSrc(const Vector<WordIndex>& s)
{
  bool found;
  return getSrcInfo(s,found).get_c_s();
}

//-------------------------
Count PhraseTable::cTrg(const Vector<WordIndex>& t)
{
  return phraseDict.getCount_t(t);  
}

//-------------------------
bool PhraseTable::nodeForTrgHasAtLeastOneTrans(const Vector<WordIndex>& t)
{
  pair<bool,PhraseTableNode*> pbp;

  pbp=nodeForTrgHasOneTransOrMore(t);
  return pbp.first;
}

//-------------------------
pair<bool,PhraseTableNode*> PhraseTable::nodeForTrgHasOneTransOrMore(const Vector<WordIndex>& t)
{
  return phraseDict.nodeForTrgHasOneTransOrMore(t);
}

//-------------------------
void PhraseTable::getPhraseGivenState(PhraseCountState ps_state,
                                      Vector<WordIndex>& s_phrase)
{
  sourcePhraseCounts.getPhraseGivenState(ps_state,s_phrase);
}
//-------------------------
Count PhraseTable::getCountGivenState(PhraseCountState ps_state)
{
  return sourcePhraseCounts.getCountGivenState(ps_state);
}

//-------------------------
size_t PhraseTable::size(void)
{
  return phraseDict.size();
}
//-------------------------
void PhraseTable::clear(void)
{
  phraseDict.clear();
  sourcePhraseCounts.clear();
}

//-------------------------
PhraseTable::~PhraseTable(void)
{

}

//-------------------------
PhraseTable::const_iterator PhraseTable::begin(void)const
{
  PhraseTable::const_iterator iter(this,phraseDict.begin());
  return iter;
}
//-------------------------
PhraseTable::const_iterator PhraseTable::end(void)const
{
  PhraseTable::const_iterator iter(this,phraseDict.end());
  return iter;
}

// const_iterator function definitions
//--------------------------
bool PhraseTable::const_iterator::operator++(void) //prefix
{
  if(ptPtr!=NULL)
  {
    ++pdIter;
    if(pdIter==ptPtr->phraseDict.end()) return false;
    else
    {
      return true;
    }
  }
  else return false;
}
//--------------------------
bool PhraseTable::const_iterator::operator++(int)  //postfix
{
  return operator++();
}
//--------------------------
int PhraseTable::const_iterator::operator==(const const_iterator& right)
{
  return (ptPtr==right.ptPtr && pdIter==right.pdIter);	
}
//--------------------------
int PhraseTable::const_iterator::operator!=(const const_iterator& right)
{
  return !((*this)==right);
}
//--------------------------
const PhraseDict::const_iterator&
PhraseTable::const_iterator::operator->(void)const
{
  return pdIter;
}

//-------------------------
